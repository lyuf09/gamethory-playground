<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Game Theory Playground | 交互博弈小沙盒</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=ZCOOL+QingKe+HuangYou&family=Rubik:wght@400;500;700;800&display=swap');

    :root {
      --bg-1: #07131f;
      --bg-2: #10263c;
      --bg-3: #0d1726;
      --panel: rgba(9, 17, 31, 0.84);
      --panel-soft: rgba(255, 255, 255, 0.03);
      --panel-line: rgba(255, 255, 255, 0.1);
      --text: #eef4ff;
      --muted: #9eb1ca;
      --accent: #ffd77a;
      --accent-2: #7fe7ff;
      --good: #7be6b0;
      --warn: #ffb56e;
      --danger: #ff7b8a;
      --row-best: rgba(102, 184, 255, 0.16);
      --col-best: rgba(255, 135, 184, 0.14);
      --pure-ring: rgba(255, 215, 122, 0.9);
      --shadow: 0 20px 42px rgba(4, 7, 14, 0.5);
      --radius: 18px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      color: var(--text);
      font-family: "Rubik", "Noto Sans SC", "PingFang SC", "Microsoft YaHei", system-ui, sans-serif;
      min-height: 100vh;
      background:
        radial-gradient(60vmax 46vmax at 8% -5%, rgba(255, 215, 122, 0.12), transparent 62%),
        radial-gradient(50vmax 42vmax at 100% 0%, rgba(127, 231, 255, 0.12), transparent 60%),
        radial-gradient(60vmax 40vmax at 50% 115%, rgba(143, 130, 255, 0.08), transparent 65%),
        linear-gradient(180deg, var(--bg-2), var(--bg-1));
      padding: 18px;
    }

    button, input, select {
      font: inherit;
    }

    .app {
      width: min(1280px, 100%);
      margin: 0 auto;
      display: grid;
      gap: 14px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--panel-line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    .hero {
      padding: 14px;
      display: grid;
      gap: 12px;
    }

    .hero-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }

    .back {
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 999px;
      text-decoration: none;
      font-size: 13px;
    }

    .hero h1 {
      margin: 0;
      font-family: "ZCOOL QingKe HuangYou", "Rubik", sans-serif;
      letter-spacing: 1.6px;
      font-size: clamp(28px, 4.8vw, 42px);
    }

    .subtitle {
      color: var(--muted);
      line-height: 1.5;
      font-size: 14px;
      max-width: 72ch;
    }

    .feature-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .badge {
      border-radius: 999px;
      padding: 7px 10px;
      font-size: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      background: linear-gradient(160deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      color: #dbe9ff;
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(350px, 520px) minmax(0, 1fr);
      gap: 14px;
      align-items: start;
    }

    .builder, .results {
      padding: 14px;
      display: grid;
      gap: 12px;
    }

    .section-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }

    .section-title h2,
    .section-title h3 {
      margin: 0;
      font-size: 16px;
      letter-spacing: 0.3px;
    }

    .hint {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
    }

    .control-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .field {
      display: grid;
      gap: 6px;
    }

    .field label {
      color: var(--muted);
      font-size: 12px;
    }

    .field select,
    .field input[type="number"] {
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      padding: 9px 10px;
      width: 100%;
    }

    .button-row {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }

    .button-row.four {
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }

    button {
      border: none;
      border-radius: 12px;
      padding: 10px 12px;
      cursor: pointer;
      font-weight: 700;
      color: #1b1b1b;
      background: linear-gradient(160deg, #ffd77a, #ffb85d);
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.22);
      transition: transform 0.12s ease, filter 0.12s ease;
    }

    button:hover { filter: brightness(1.03); }
    button:active { transform: translateY(1px) scale(0.995); }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }

    button.secondary {
      color: #e7eeff;
      background: linear-gradient(160deg, #425a85, #2f3e5f);
    }

    button.ghost {
      color: #dbe8ff;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: none;
    }

    .toggle-line {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: var(--muted);
    }

    .toggle-line input {
      accent-color: #8bdcff;
      width: 16px;
      height: 16px;
    }

    .matrix-shell {
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(160deg, rgba(255,255,255,0.04), rgba(255,255,255,0.015));
      padding: 10px;
      overflow-x: auto;
    }

    .matrix-table {
      border-collapse: separate;
      border-spacing: 6px;
      width: max-content;
      min-width: 100%;
    }

    .matrix-table th {
      color: var(--muted);
      font-size: 12px;
      font-weight: 600;
      text-align: center;
      min-width: 70px;
      transition: opacity 0.25s ease, transform 0.25s ease;
    }

    .matrix-table th.corner {
      min-width: 52px;
      color: rgba(255,255,255,0.5);
    }

    .matrix-table td {
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 14px;
      background: rgba(255,255,255,0.03);
      min-width: 132px;
      padding: 8px;
      position: relative;
      transition: transform 0.25s ease, opacity 0.25s ease, filter 0.25s ease, border-color 0.25s ease;
      overflow: hidden;
    }

    .matrix-table td::before {
      content: "";
      position: absolute;
      inset: 0;
      background: transparent;
      pointer-events: none;
      transition: background 0.25s ease;
    }

    .matrix-table td.row-best::before {
      background: linear-gradient(160deg, var(--row-best), rgba(0,0,0,0));
    }

    .matrix-table td.col-best::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(345deg, var(--col-best), rgba(0,0,0,0));
      pointer-events: none;
    }

    .matrix-table td.pure {
      border-color: rgba(255, 215, 122, 0.6);
      box-shadow: inset 0 0 0 1px rgba(255,215,122,0.35), 0 0 0 1px rgba(255,215,122,0.18);
    }

    .matrix-table td.pure .tag-pure {
      display: inline-flex;
    }

    .payoff-pair {
      position: relative;
      z-index: 1;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 6px;
    }

    .payoff-input {
      width: 100%;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.13);
      background: rgba(5, 12, 24, 0.62);
      color: var(--text);
      padding: 8px;
      text-align: center;
      font-weight: 600;
      min-width: 0;
    }

    .payoff-input:focus {
      outline: 2px solid rgba(127, 231, 255, 0.45);
      outline-offset: 1px;
    }

    .payoff-input.row-payoff { color: #bfe6ff; }
    .payoff-input.col-payoff { color: #ffd0e8; }

    .comma {
      color: rgba(255,255,255,0.5);
      font-weight: 700;
      font-size: 13px;
    }

    .cell-tags {
      margin-top: 6px;
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      position: relative;
      z-index: 1;
      min-height: 18px;
    }

    .tag {
      display: inline-flex;
      align-items: center;
      border-radius: 999px;
      padding: 2px 7px;
      font-size: 10px;
      border: 1px solid rgba(255,255,255,0.1);
      color: #dce8ff;
      background: rgba(255,255,255,0.04);
    }

    .tag.row { border-color: rgba(102,184,255,0.28); color: #bfe6ff; background: rgba(102,184,255,0.1); }
    .tag.col { border-color: rgba(255,135,184,0.28); color: #ffd0e8; background: rgba(255,135,184,0.1); }
    .tag.tag-pure { display: none; border-color: rgba(255,215,122,0.35); color: #ffe6b3; background: rgba(255,215,122,0.12); }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    .legend .dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display: inline-block;
      margin-right: 5px;
      vertical-align: -1px;
    }

    .legend-item {
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 999px;
      padding: 5px 8px;
      background: rgba(255,255,255,0.03);
    }

    .results {
      grid-template-rows: auto auto auto;
      align-content: start;
    }

    .stack {
      display: grid;
      gap: 12px;
    }

    .result-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
    }

    .card {
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.08);
      background: var(--panel-soft);
      padding: 12px;
      display: grid;
      gap: 8px;
      min-height: 142px;
    }

    .card h3 {
      margin: 0;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .solver-note {
      color: var(--muted);
      font-size: 11px;
      font-weight: 500;
    }

    .list {
      display: grid;
      gap: 8px;
      align-content: start;
    }

    .pill {
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.03);
      padding: 8px 10px;
      display: grid;
      gap: 4px;
    }

    .pill strong {
      font-size: 13px;
    }

    .pill .meta {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.35;
    }

    .empty {
      color: var(--muted);
      font-size: 13px;
      line-height: 1.5;
      border-radius: 12px;
      border: 1px dashed rgba(255,255,255,0.12);
      padding: 10px;
      background: rgba(255,255,255,0.02);
    }

    .explain-box {
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.03);
      padding: 12px;
      white-space: pre-wrap;
      line-height: 1.62;
      color: #e8f1ff;
      min-height: 170px;
      font-size: 13px;
    }

    .explain-box.placeholder {
      color: var(--muted);
    }

    .action-inline {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .iesds-wrap {
      display: grid;
      gap: 10px;
    }

    .iesds-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }

    .iesds-status {
      color: #dce8ff;
      font-size: 13px;
      line-height: 1.45;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.03);
      padding: 9px 10px;
    }

    .iesds-stage {
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.02);
      padding: 10px;
      overflow-x: auto;
    }

    .iesds-table {
      border-collapse: separate;
      border-spacing: 6px;
      width: max-content;
      min-width: 100%;
    }

    .iesds-table th,
    .iesds-table td {
      text-align: center;
      transition: opacity 0.3s ease, transform 0.3s ease, filter 0.3s ease, border-color 0.3s ease;
    }

    .iesds-table th {
      color: var(--muted);
      font-size: 12px;
      min-width: 68px;
    }

    .iesds-table td {
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.03);
      padding: 8px 10px;
      min-width: 96px;
      font-size: 12px;
      line-height: 1.3;
      color: #e8f2ff;
    }

    .iesds-table .inactive {
      opacity: 0.34;
      filter: grayscale(0.55);
    }

    .iesds-table .removed {
      opacity: 0.18;
      transform: scale(0.95);
      filter: grayscale(0.9);
    }

    .iesds-table .dominator {
      border-color: rgba(123, 230, 176, 0.45);
      background: rgba(123, 230, 176, 0.08);
      box-shadow: inset 0 0 0 1px rgba(123, 230, 176, 0.12);
    }

    .iesds-table .focus-cut {
      border-color: rgba(255, 123, 138, 0.45);
      background: rgba(255, 123, 138, 0.08);
      box-shadow: inset 0 0 0 1px rgba(255, 123, 138, 0.12);
    }

    .iesds-table .head-dominator {
      color: #bdf3d8;
    }

    .iesds-table .head-cut {
      color: #ffbac2;
    }

    .timeline {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 2px;
    }

    .timeline button {
      min-width: max-content;
      box-shadow: none;
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 999px;
    }

    .timeline button.ghost.active-step {
      background: rgba(127, 231, 255, 0.18);
      border-color: rgba(127, 231, 255, 0.34);
      color: #dcf8ff;
    }

    .small-note {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.45;
    }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    @media (max-width: 1040px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .result-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 680px) {
      body { padding: 12px; }
      .control-grid { grid-template-columns: 1fr 1fr; }
      .button-row { grid-template-columns: 1fr; }
      .button-row.four { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .matrix-table td { min-width: 118px; padding: 7px; }
      .payoff-input { padding: 7px; }
    }

    @media (prefers-reduced-motion: reduce) {
      * {
        animation: none !important;
        transition: none !important;
        scroll-behavior: auto !important;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <section class="hero panel">
      <div class="hero-top">
        <a class="back" href="./">← 项目首页</a>
        <div class="hint">左数是行玩家 payoff，右数是列玩家 payoff</div>
      </div>
      <div>
        <h1>Game Theory Playground</h1>
        <div class="subtitle">
          输入 payoff matrix，自动找纯策略 / 混合策略 Nash（小规模支持集枚举），并用 IESDS 做一步步删策略动画。适合复习、教学和作品集展示。
        </div>
      </div>
      <div class="feature-badges">
        <span class="badge">Pure Nash 自动标亮</span>
        <span class="badge">Mixed Nash（2x2~4x4 常见情形）</span>
        <span class="badge">IESDS 动画演示</span>
        <span class="badge">学生风解释按钮</span>
      </div>
    </section>

    <section class="layout">
      <section class="builder panel" aria-label="矩阵输入区">
        <div class="section-title">
          <h2>1. 输入博弈矩阵</h2>
          <div class="hint">支持 2~4 行、2~4 列</div>
        </div>

        <div class="control-grid">
          <div class="field">
            <label for="rowCount">行策略数（Row Player）</label>
            <select id="rowCount">
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
          </div>
          <div class="field">
            <label for="colCount">列策略数（Column Player）</label>
            <select id="colCount">
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
            </select>
          </div>
          <div class="field" style="grid-column: 1 / -1;">
            <label for="presetSelect">预设案例</label>
            <select id="presetSelect"></select>
          </div>
        </div>

        <div class="button-row">
          <button id="applyPresetBtn" type="button">载入预设</button>
          <button id="randomBtn" class="secondary" type="button">随机矩阵</button>
          <button id="solveBtn" class="ghost" type="button">重新分析</button>
        </div>

        <label class="toggle-line">
          <input id="highlightToggle" type="checkbox" checked />
          <span>在输入矩阵里高亮最佳回应 / 纯策略纳什格子</span>
        </label>

        <div class="matrix-shell">
          <div id="matrixMount"></div>
        </div>

        <div class="legend">
          <span class="legend-item"><span class="dot" style="background: rgba(102,184,255,0.85)"></span>行玩家最佳回应</span>
          <span class="legend-item"><span class="dot" style="background: rgba(255,135,184,0.9)"></span>列玩家最佳回应</span>
          <span class="legend-item"><span class="dot" style="background: rgba(255,215,122,0.95)"></span>纯策略 Nash</span>
        </div>
      </section>

      <section class="results panel" aria-label="分析结果区">
        <div class="stack">
          <div class="section-title">
            <h2>2. 均衡分析结果</h2>
            <div class="hint" id="analysisSummary">正在分析…</div>
          </div>

          <div class="result-grid">
            <section class="card">
              <h3>
                <span>Pure Nash</span>
                <span class="solver-note" id="pureCount"></span>
              </h3>
              <div id="pureList" class="list"></div>
            </section>

            <section class="card">
              <h3>
                <span>Mixed Nash</span>
                <span class="solver-note">支持集枚举（小规模）</span>
              </h3>
              <div id="mixedList" class="list"></div>
            </section>
          </div>
        </div>

        <div class="stack">
          <div class="section-title">
            <h2>3. 学生风解释</h2>
            <div class="action-inline">
              <button id="explainBtn" type="button">生成解释</button>
              <button id="copyExplainBtn" class="ghost" type="button">复制解释</button>
            </div>
          </div>
          <div id="explainBox" class="explain-box placeholder">点击“生成解释”，我会用通俗语言解释为什么这些策略组合是（或不是）纳什均衡，以及 IESDS 在删什么。</div>
        </div>

        <div class="stack">
          <div class="iesds-top">
            <div class="section-title">
              <h2>4. IESDS 动画（严格支配策略迭代删除）</h2>
            </div>
            <div class="action-inline button-row four" style="width: min(520px, 100%);">
              <button id="iesdsResetBtn" class="ghost" type="button">重置</button>
              <button id="iesdsPrevBtn" class="ghost" type="button">上一步</button>
              <button id="iesdsNextBtn" class="secondary" type="button">下一步</button>
              <button id="iesdsPlayBtn" type="button">播放</button>
            </div>
          </div>

          <div class="iesds-wrap">
            <div id="iesdsStatus" class="iesds-status">准备中…</div>
            <div class="iesds-stage">
              <div id="iesdsMatrix"></div>
            </div>
            <div id="iesdsTimeline" class="timeline" aria-label="IESDS 时间线"></div>
            <div class="small-note">
              当前演示按“先找行玩家被严格支配策略，再找列玩家被严格支配策略”的固定顺序执行。这里使用的是“被纯策略严格支配”的 IESDS 版本，适合课堂入门演示。
            </div>
          </div>
        </div>
      </section>
    </section>
  </div>

  <script>
    const EPS = 1e-8;
    const DISPLAY_EPS = 1e-6;

    const PRESETS = {
      pd: {
        name: "囚徒困境 (Prisoner's Dilemma)",
        rows: 2,
        cols: 2,
        rowLabels: ["合作", "背叛"],
        colLabels: ["合作", "背叛"],
        A: [[-1, -3], [0, -2]],
        B: [[-1, 0], [-3, -2]]
      },
      bos: {
        name: "性别之战 (Battle of the Sexes)",
        rows: 2,
        cols: 2,
        rowLabels: ["歌剧", "足球"],
        colLabels: ["歌剧", "足球"],
        A: [[2, 0], [0, 1]],
        B: [[1, 0], [0, 2]]
      },
      matching: {
        name: "正反硬币 (Matching Pennies)",
        rows: 2,
        cols: 2,
        rowLabels: ["正", "反"],
        colLabels: ["正", "反"],
        A: [[1, -1], [-1, 1]],
        B: [[-1, 1], [1, -1]]
      },
      stag: {
        name: "鹿猎博弈 (Stag Hunt)",
        rows: 2,
        cols: 2,
        rowLabels: ["猎鹿", "捉兔"],
        colLabels: ["猎鹿", "捉兔"],
        A: [[4, 0], [3, 2]],
        B: [[4, 3], [0, 2]]
      },
      chicken: {
        name: "胆小鬼博弈 (Chicken)",
        rows: 2,
        cols: 2,
        rowLabels: ["直行", "转向"],
        colLabels: ["直行", "转向"],
        A: [[-10, 2], [0, 1]],
        B: [[-10, 0], [2, 1]]
      },
      rps: {
        name: "石头剪刀布 (RPS)",
        rows: 3,
        cols: 3,
        rowLabels: ["石头", "剪刀", "布"],
        colLabels: ["石头", "剪刀", "布"],
        A: [[0, 1, -1], [-1, 0, 1], [1, -1, 0]],
        B: [[0, -1, 1], [1, 0, -1], [-1, 1, 0]]
      }
    };

    const els = {
      rowCount: document.getElementById('rowCount'),
      colCount: document.getElementById('colCount'),
      presetSelect: document.getElementById('presetSelect'),
      applyPresetBtn: document.getElementById('applyPresetBtn'),
      randomBtn: document.getElementById('randomBtn'),
      solveBtn: document.getElementById('solveBtn'),
      highlightToggle: document.getElementById('highlightToggle'),
      matrixMount: document.getElementById('matrixMount'),
      pureList: document.getElementById('pureList'),
      mixedList: document.getElementById('mixedList'),
      pureCount: document.getElementById('pureCount'),
      analysisSummary: document.getElementById('analysisSummary'),
      explainBtn: document.getElementById('explainBtn'),
      copyExplainBtn: document.getElementById('copyExplainBtn'),
      explainBox: document.getElementById('explainBox'),
      iesdsStatus: document.getElementById('iesdsStatus'),
      iesdsMatrix: document.getElementById('iesdsMatrix'),
      iesdsTimeline: document.getElementById('iesdsTimeline'),
      iesdsResetBtn: document.getElementById('iesdsResetBtn'),
      iesdsPrevBtn: document.getElementById('iesdsPrevBtn'),
      iesdsNextBtn: document.getElementById('iesdsNextBtn'),
      iesdsPlayBtn: document.getElementById('iesdsPlayBtn')
    };

    const state = {
      rows: 2,
      cols: 2,
      rowLabels: ['R1', 'R2'],
      colLabels: ['C1', 'C2'],
      A: [[0, 0], [0, 0]],
      B: [[0, 0], [0, 0]],
      highlightBest: true,
      analysis: null,
      explainText: '',
      iesdsStepIndex: 0,
      iesdsPlaying: false,
      iesdsTimer: null
    };

    function init() {
      buildPresetSelect();
      els.highlightToggle.checked = state.highlightBest;
      bindEvents();
      applyPreset('pd');
    }

    function buildPresetSelect() {
      const entries = Object.entries(PRESETS);
      els.presetSelect.innerHTML = entries.map(([key, preset]) => (
        `<option value="${escapeHtml(key)}">${escapeHtml(preset.name)}</option>`
      )).join('');
      els.presetSelect.value = 'pd';
    }

    function bindEvents() {
      els.rowCount.addEventListener('change', () => {
        resizeGame(parseInt(els.rowCount.value, 10), state.cols);
      });
      els.colCount.addEventListener('change', () => {
        resizeGame(state.rows, parseInt(els.colCount.value, 10));
      });

      els.applyPresetBtn.addEventListener('click', () => applyPreset(els.presetSelect.value));
      els.randomBtn.addEventListener('click', randomizeMatrix);
      els.solveBtn.addEventListener('click', () => runAnalysis({ regenerateExplanationPlaceholder: false }));

      els.highlightToggle.addEventListener('change', () => {
        state.highlightBest = els.highlightToggle.checked;
        renderMatrixEditor();
      });

      els.matrixMount.addEventListener('input', handleMatrixInput);
      els.matrixMount.addEventListener('change', handleMatrixInput);

      els.explainBtn.addEventListener('click', () => {
        state.explainText = buildStudentExplanation();
        renderExplanation();
      });

      els.copyExplainBtn.addEventListener('click', async () => {
        if (!state.explainText) {
          state.explainText = buildStudentExplanation();
          renderExplanation();
        }
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(state.explainText);
            flashExplainStatus('已复制解释到剪贴板。');
          } else {
            flashExplainStatus('浏览器不支持剪贴板 API，可手动复制下方文字。');
          }
        } catch (err) {
          flashExplainStatus('复制失败，请手动复制。');
        }
      });

      els.iesdsResetBtn.addEventListener('click', () => setIesdsStep(0));
      els.iesdsPrevBtn.addEventListener('click', () => setIesdsStep(Math.max(0, state.iesdsStepIndex - 1)));
      els.iesdsNextBtn.addEventListener('click', () => {
        const max = getIesdsStepCount();
        setIesdsStep(Math.min(max, state.iesdsStepIndex + 1));
      });
      els.iesdsPlayBtn.addEventListener('click', toggleIesdsPlay);

      window.addEventListener('beforeunload', stopIesdsPlay);
    }

    function flashExplainStatus(message) {
      const old = els.analysisSummary.textContent;
      els.analysisSummary.textContent = message;
      setTimeout(() => {
        if (els.analysisSummary.textContent === message) {
          renderSummaryText();
        } else if (old) {
          renderSummaryText();
        }
      }, 1200);
    }

    function applyPreset(key) {
      const preset = PRESETS[key];
      if (!preset) return;

      state.rows = preset.rows;
      state.cols = preset.cols;
      state.A = cloneMatrix(preset.A);
      state.B = cloneMatrix(preset.B);
      state.rowLabels = ensureLabelArray(preset.rowLabels, preset.rows, 'R');
      state.colLabels = ensureLabelArray(preset.colLabels, preset.cols, 'C');

      syncSizeControls();
      renderMatrixEditor();
      runAnalysis();
    }

    function randomizeMatrix() {
      for (let i = 0; i < state.rows; i++) {
        for (let j = 0; j < state.cols; j++) {
          state.A[i][j] = randomInt(-4, 6);
          state.B[i][j] = randomInt(-4, 6);
        }
      }
      renderMatrixEditor();
      runAnalysis();
    }

    function resizeGame(newRows, newCols) {
      newRows = clamp(newRows, 2, 4);
      newCols = clamp(newCols, 2, 4);

      const nextA = Array.from({ length: newRows }, (_, i) =>
        Array.from({ length: newCols }, (_, j) => (state.A[i] && Number.isFinite(state.A[i][j]) ? state.A[i][j] : 0))
      );
      const nextB = Array.from({ length: newRows }, (_, i) =>
        Array.from({ length: newCols }, (_, j) => (state.B[i] && Number.isFinite(state.B[i][j]) ? state.B[i][j] : 0))
      );

      state.rows = newRows;
      state.cols = newCols;
      state.A = nextA;
      state.B = nextB;
      state.rowLabels = ensureLabelArray(state.rowLabels, newRows, 'R');
      state.colLabels = ensureLabelArray(state.colLabels, newCols, 'C');

      renderMatrixEditor();
      runAnalysis();
    }

    function syncSizeControls() {
      els.rowCount.value = String(state.rows);
      els.colCount.value = String(state.cols);
    }

    function handleMatrixInput(event) {
      const target = event.target;
      if (!(target instanceof HTMLInputElement)) return;
      if (!target.classList.contains('payoff-input')) return;

      const i = Number(target.dataset.i);
      const j = Number(target.dataset.j);
      const player = target.dataset.player;
      const value = Number(target.value);
      if (!Number.isFinite(i) || !Number.isFinite(j) || !player) return;
      if (!Number.isFinite(value)) return;

      if (player === 'row') state.A[i][j] = value;
      if (player === 'col') state.B[i][j] = value;

      runAnalysis({ rerenderMatrix: false });
    }

    function runAnalysis(options = {}) {
      const { rerenderMatrix = false, regenerateExplanationPlaceholder = true } = options;
      stopIesdsPlay();

      state.analysis = analyzeGame(state.A, state.B, state.rowLabels, state.colLabels);
      state.iesdsStepIndex = 0;

      if (rerenderMatrix) renderMatrixEditor();
      else refreshMatrixDecorations();

      renderResults();
      renderIesdsPanel();

      if (regenerateExplanationPlaceholder) {
        state.explainText = '';
        renderExplanation();
      }
    }

    function analyzeGame(A, B, rowLabels, colLabels) {
      const bestResponses = computeBestResponses(A, B);
      const pureNash = computePureNash(A, B, bestResponses);
      const mixedNash = computeMixedNashSupportEnumeration(A, B);
      const iesds = computeIesds(A, B, rowLabels, colLabels);
      return { bestResponses, pureNash, mixedNash, iesds };
    }

    function computeBestResponses(A, B) {
      const m = A.length;
      const n = A[0].length;
      const rowBestByCol = Array.from({ length: n }, () => []);
      const colBestByRow = Array.from({ length: m }, () => []);

      for (let j = 0; j < n; j++) {
        let best = -Infinity;
        for (let i = 0; i < m; i++) best = Math.max(best, A[i][j]);
        for (let i = 0; i < m; i++) {
          if (Math.abs(A[i][j] - best) <= DISPLAY_EPS) rowBestByCol[j].push(i);
        }
      }

      for (let i = 0; i < m; i++) {
        let best = -Infinity;
        for (let j = 0; j < n; j++) best = Math.max(best, B[i][j]);
        for (let j = 0; j < n; j++) {
          if (Math.abs(B[i][j] - best) <= DISPLAY_EPS) colBestByRow[i].push(j);
        }
      }

      return { rowBestByCol, colBestByRow };
    }

    function computePureNash(A, B, bestResponses = computeBestResponses(A, B)) {
      const m = A.length;
      const n = A[0].length;
      const pure = [];
      for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
          const rowBest = bestResponses.rowBestByCol[j].includes(i);
          const colBest = bestResponses.colBestByRow[i].includes(j);
          if (rowBest && colBest) {
            pure.push({ i, j, payoff: [A[i][j], B[i][j]] });
          }
        }
      }
      return pure;
    }

    function computeMixedNashSupportEnumeration(A, B) {
      const m = A.length;
      const n = A[0].length;
      const limit = 4;
      if (m > limit || n > limit) {
        return { equilibria: [], truncated: true, note: '矩阵太大，当前页面只做 <=4x4 的支持集枚举。' };
      }

      const maxK = Math.min(m, n);
      const equilibria = [];
      const seen = new Set();

      for (let k = 2; k <= maxK; k++) {
        const rowSupports = combinations(m, k);
        const colSupports = combinations(n, k);
        for (const I of rowSupports) {
          for (const J of colSupports) {
            const qSupport = solveColumnMixForRowSupport(A, I, J);
            if (!qSupport) continue;
            const pSupport = solveRowMixForColSupport(B, I, J);
            if (!pSupport) continue;

            if (!allStrictlyPositive(qSupport) || !allStrictlyPositive(pSupport)) continue;

            const p = Array(m).fill(0);
            const q = Array(n).fill(0);
            for (let t = 0; t < k; t++) {
              p[I[t]] = pSupport[t];
              q[J[t]] = qSupport[t];
            }

            normalizeTinyInPlace(p);
            normalizeTinyInPlace(q);

            if (isPureStrategyVector(p) && isPureStrategyVector(q)) continue;

            const rowPayoffs = computeRowExpectedPayoffs(A, q);
            const colPayoffs = computeColExpectedPayoffs(B, p);
            const rowValue = rowPayoffs[I[0]];
            const colValue = colPayoffs[J[0]];

            let valid = true;
            for (const i of I) {
              if (Math.abs(rowPayoffs[i] - rowValue) > 1e-5) { valid = false; break; }
            }
            if (!valid) continue;
            for (const j of J) {
              if (Math.abs(colPayoffs[j] - colValue) > 1e-5) { valid = false; break; }
            }
            if (!valid) continue;

            for (let i = 0; i < m; i++) {
              if (rowPayoffs[i] > rowValue + 1e-5) { valid = false; break; }
            }
            if (!valid) continue;
            for (let j = 0; j < n; j++) {
              if (colPayoffs[j] > colValue + 1e-5) { valid = false; break; }
            }
            if (!valid) continue;

            const key = probsKey(p, q);
            if (seen.has(key)) continue;
            seen.add(key);

            equilibria.push({
              p,
              q,
              rowSupport: [...I],
              colSupport: [...J],
              rowValue,
              colValue
            });
          }
        }
      }

      equilibria.sort((a, b) => {
        const sa = a.rowSupport.length + a.colSupport.length;
        const sb = b.rowSupport.length + b.colSupport.length;
        if (sa !== sb) return sa - sb;
        return probsKey(a.p, a.q).localeCompare(probsKey(b.p, b.q));
      });

      return { equilibria, truncated: false, note: '' };
    }

    function solveColumnMixForRowSupport(A, I, J) {
      const k = I.length;
      const M = [];
      const b = [];
      for (let r = 1; r < k; r++) {
        const row = [];
        for (let c = 0; c < k; c++) {
          row.push(A[I[r]][J[c]] - A[I[0]][J[c]]);
        }
        M.push(row);
        b.push(0);
      }
      M.push(Array(k).fill(1));
      b.push(1);
      const sol = solveLinearSystem(M, b);
      if (!sol) return null;
      return sanitizeProbabilities(sol);
    }

    function solveRowMixForColSupport(B, I, J) {
      const k = J.length;
      const M = [];
      const b = [];
      for (let c = 1; c < k; c++) {
        const row = [];
        for (let r = 0; r < I.length; r++) {
          row.push(B[I[r]][J[c]] - B[I[r]][J[0]]);
        }
        M.push(row);
        b.push(0);
      }
      M.push(Array(I.length).fill(1));
      b.push(1);
      const sol = solveLinearSystem(M, b);
      if (!sol) return null;
      return sanitizeProbabilities(sol);
    }

    function sanitizeProbabilities(arr) {
      if (!arr) return null;
      const copy = arr.map(v => (Math.abs(v) < 1e-10 ? 0 : v));
      const sum = copy.reduce((s, v) => s + v, 0);
      if (!Number.isFinite(sum) || Math.abs(sum) < 1e-10) return null;
      for (let i = 0; i < copy.length; i++) copy[i] /= sum;
      return copy;
    }

    function solveLinearSystem(matrix, rhs) {
      const n = matrix.length;
      if (!n || matrix.some(row => row.length !== n) || rhs.length !== n) return null;
      const a = matrix.map((row, i) => [...row, rhs[i]]);

      for (let col = 0; col < n; col++) {
        let pivot = col;
        for (let r = col + 1; r < n; r++) {
          if (Math.abs(a[r][col]) > Math.abs(a[pivot][col])) pivot = r;
        }
        if (Math.abs(a[pivot][col]) < 1e-10) return null;
        if (pivot !== col) [a[pivot], a[col]] = [a[col], a[pivot]];

        const pivotVal = a[col][col];
        for (let c = col; c <= n; c++) a[col][c] /= pivotVal;

        for (let r = 0; r < n; r++) {
          if (r === col) continue;
          const factor = a[r][col];
          if (Math.abs(factor) < 1e-12) continue;
          for (let c = col; c <= n; c++) {
            a[r][c] -= factor * a[col][c];
          }
        }
      }

      return a.map(row => row[n]);
    }

    function computeRowExpectedPayoffs(A, q) {
      return A.map(row => dot(row, q));
    }

    function computeColExpectedPayoffs(B, p) {
      const m = B.length;
      const n = B[0].length;
      const out = Array(n).fill(0);
      for (let j = 0; j < n; j++) {
        let total = 0;
        for (let i = 0; i < m; i++) total += p[i] * B[i][j];
        out[j] = total;
      }
      return out;
    }

    function computeIesds(A, B, rowLabels, colLabels) {
      const m = A.length;
      const n = A[0].length;
      let activeRows = Array.from({ length: m }, (_, i) => i);
      let activeCols = Array.from({ length: n }, (_, j) => j);
      const steps = [];

      let guard = 0;
      while (guard++ < m + n + 10) {
        const rowStep = findStrictlyDominatedRow(A, activeRows, activeCols);
        if (rowStep) {
          const before = { activeRows: [...activeRows], activeCols: [...activeCols] };
          activeRows = activeRows.filter(i => i !== rowStep.removed);
          const after = { activeRows: [...activeRows], activeCols: [...activeCols] };
          steps.push({
            type: 'row',
            removed: rowStep.removed,
            by: rowStep.by,
            before,
            after,
            text: `删除行策略 ${rowLabels[rowStep.removed]}，因为在当前剩余列策略下，它被 ${rowLabels[rowStep.by]} 严格支配。`
          });
          continue;
        }

        const colStep = findStrictlyDominatedCol(B, activeRows, activeCols);
        if (colStep) {
          const before = { activeRows: [...activeRows], activeCols: [...activeCols] };
          activeCols = activeCols.filter(j => j !== colStep.removed);
          const after = { activeRows: [...activeRows], activeCols: [...activeCols] };
          steps.push({
            type: 'col',
            removed: colStep.removed,
            by: colStep.by,
            before,
            after,
            text: `删除列策略 ${colLabels[colStep.removed]}，因为在当前剩余行策略下，它被 ${colLabels[colStep.by]} 严格支配。`
          });
          continue;
        }

        break;
      }

      return {
        initial: {
          activeRows: Array.from({ length: m }, (_, i) => i),
          activeCols: Array.from({ length: n }, (_, j) => j)
        },
        steps,
        final: { activeRows, activeCols }
      };
    }

    function findStrictlyDominatedRow(A, activeRows, activeCols) {
      for (const removed of activeRows) {
        for (const by of activeRows) {
          if (removed === by) continue;
          let strictAll = true;
          for (const j of activeCols) {
            if (!(A[by][j] > A[removed][j] + DISPLAY_EPS)) {
              strictAll = false;
              break;
            }
          }
          if (strictAll) return { removed, by };
        }
      }
      return null;
    }

    function findStrictlyDominatedCol(B, activeRows, activeCols) {
      for (const removed of activeCols) {
        for (const by of activeCols) {
          if (removed === by) continue;
          let strictAll = true;
          for (const i of activeRows) {
            if (!(B[i][by] > B[i][removed] + DISPLAY_EPS)) {
              strictAll = false;
              break;
            }
          }
          if (strictAll) return { removed, by };
        }
      }
      return null;
    }

    function renderMatrixEditor() {
      const br = computeBestResponses(state.A, state.B);
      const pureSet = new Set(computePureNash(state.A, state.B, br).map(item => `${item.i},${item.j}`));

      let html = '<table class="matrix-table" aria-label="Payoff matrix"><thead><tr><th class="corner">R\\C</th>';
      for (let j = 0; j < state.cols; j++) {
        html += `<th>${escapeHtml(state.colLabels[j])}</th>`;
      }
      html += '</tr></thead><tbody>';

      for (let i = 0; i < state.rows; i++) {
        html += `<tr><th>${escapeHtml(state.rowLabels[i])}</th>`;
        for (let j = 0; j < state.cols; j++) {
          const rowBest = br.rowBestByCol[j].includes(i);
          const colBest = br.colBestByRow[i].includes(j);
          const pure = pureSet.has(`${i},${j}`);
          const classes = [];
          if (state.highlightBest) {
            if (rowBest) classes.push('row-best');
            if (colBest) classes.push('col-best');
            if (pure) classes.push('pure');
          }
          html += `
            <td class="${classes.join(' ')}" data-i="${i}" data-j="${j}">
              <div class="payoff-pair">
                <label>
                  <span class="sr-only">${escapeHtml(state.rowLabels[i])}, ${escapeHtml(state.colLabels[j])} 行玩家收益</span>
                  <input class="payoff-input row-payoff" data-player="row" data-i="${i}" data-j="${j}" type="number" step="0.1" value="${escapeAttr(formatEditable(state.A[i][j]))}" />
                </label>
                <span class="comma">,</span>
                <label>
                  <span class="sr-only">${escapeHtml(state.rowLabels[i])}, ${escapeHtml(state.colLabels[j])} 列玩家收益</span>
                  <input class="payoff-input col-payoff" data-player="col" data-i="${i}" data-j="${j}" type="number" step="0.1" value="${escapeAttr(formatEditable(state.B[i][j]))}" />
                </label>
              </div>
              <div class="cell-tags">
                <span class="tag row" style="display:${state.highlightBest && rowBest ? 'inline-flex' : 'none'}">行最佳</span>
                <span class="tag col" style="display:${state.highlightBest && colBest ? 'inline-flex' : 'none'}">列最佳</span>
                <span class="tag tag-pure" style="display:${state.highlightBest && pure ? 'inline-flex' : 'none'}">Pure NE</span>
              </div>
            </td>`;
        }
        html += '</tr>';
      }
      html += '</tbody></table>';
      els.matrixMount.innerHTML = html;
    }

    function refreshMatrixDecorations() {
      const analysis = state.analysis;
      if (!analysis) return;
      const pureSet = new Set(analysis.pureNash.map(item => `${item.i},${item.j}`));
      const br = analysis.bestResponses;
      const cells = els.matrixMount.querySelectorAll('td[data-i][data-j]');
      cells.forEach(cell => {
        const i = Number(cell.dataset.i);
        const j = Number(cell.dataset.j);
        const rowBest = br.rowBestByCol[j].includes(i);
        const colBest = br.colBestByRow[i].includes(j);
        const pure = pureSet.has(`${i},${j}`);

        cell.classList.toggle('row-best', state.highlightBest && rowBest);
        cell.classList.toggle('col-best', state.highlightBest && colBest);
        cell.classList.toggle('pure', state.highlightBest && pure);

        const tagRow = cell.querySelector('.tag.row');
        const tagCol = cell.querySelector('.tag.col');
        const tagPure = cell.querySelector('.tag-pure');
        if (tagRow) tagRow.style.display = state.highlightBest && rowBest ? 'inline-flex' : 'none';
        if (tagCol) tagCol.style.display = state.highlightBest && colBest ? 'inline-flex' : 'none';
        if (tagPure) tagPure.style.display = state.highlightBest && pure ? 'inline-flex' : 'none';
      });
    }

    function renderResults() {
      renderSummaryText();
      renderPureResults();
      renderMixedResults();
    }

    function renderSummaryText() {
      if (!state.analysis) {
        els.analysisSummary.textContent = '暂无结果';
        return;
      }
      const pureCount = state.analysis.pureNash.length;
      const mixedCount = state.analysis.mixedNash.equilibria.length;
      const iesdsSteps = state.analysis.iesds.steps.length;
      els.analysisSummary.textContent = `Pure: ${pureCount} 个 | Mixed: ${mixedCount} 个 | IESDS 删除 ${iesdsSteps} 步`;
    }

    function renderPureResults() {
      const pure = state.analysis?.pureNash || [];
      els.pureCount.textContent = `${pure.length} 个`;
      if (!pure.length) {
        els.pureList.innerHTML = '<div class="empty">没有纯策略纳什均衡：说明只盯住一个固定格子时，至少有一方会想单方面改策略。</div>';
        return;
      }

      els.pureList.innerHTML = pure.map(eq => {
        const rowAlt = bestReplyListForColumn(eq.j, 'row').join(' / ');
        const colAlt = bestReplyListForRow(eq.i, 'col').join(' / ');
        return `
          <div class="pill">
            <strong>${escapeHtml(labelCell(eq.i, eq.j))} → (${formatNum(eq.payoff[0])}, ${formatNum(eq.payoff[1])})</strong>
            <div class="meta">给定 ${escapeHtml(state.colLabels[eq.j])}，行玩家最佳回应包含：${escapeHtml(rowAlt)}</div>
            <div class="meta">给定 ${escapeHtml(state.rowLabels[eq.i])}，列玩家最佳回应包含：${escapeHtml(colAlt)}</div>
          </div>
        `;
      }).join('');
    }

    function renderMixedResults() {
      const mixedResult = state.analysis?.mixedNash;
      if (!mixedResult) {
        els.mixedList.innerHTML = '<div class="empty">暂无结果</div>';
        return;
      }

      const list = mixedResult.equilibria;
      if (!list.length) {
        const msg = mixedResult.truncated
          ? '当前矩阵规模超出页面求解范围（仅支持 <=4x4 的支持集枚举）。'
          : '未找到混合策略纳什（或该例子属于求解器未覆盖的退化情形）。可先试试常见 2x2 / 3x3 预设。';
        els.mixedList.innerHTML = `<div class="empty">${escapeHtml(msg)}</div>`;
        return;
      }

      els.mixedList.innerHTML = list.map((eq, idx) => {
        const rowMix = formatStrategyDistribution(eq.p, state.rowLabels);
        const colMix = formatStrategyDistribution(eq.q, state.colLabels);
        return `
          <div class="pill">
            <strong>Mixed NE ${idx + 1}</strong>
            <div class="meta">行玩家：${escapeHtml(rowMix)}</div>
            <div class="meta">列玩家：${escapeHtml(colMix)}</div>
            <div class="meta">期望收益 ≈ (${formatNum(eq.rowValue)}, ${formatNum(eq.colValue)})</div>
          </div>
        `;
      }).join('');
    }

    function renderExplanation() {
      if (!state.explainText) {
        els.explainBox.textContent = '点击“生成解释”，我会用通俗语言解释为什么这些策略组合是（或不是）纳什均衡，以及 IESDS 在删什么。';
        els.explainBox.classList.add('placeholder');
        return;
      }
      els.explainBox.textContent = state.explainText;
      els.explainBox.classList.remove('placeholder');
    }

    function buildStudentExplanation() {
      if (!state.analysis) return '还没有分析结果。';

      const { pureNash, mixedNash, iesds } = state.analysis;
      const lines = [];

      lines.push('先把这张表当成“同时出招”的成绩单：每个格子左边分数给行玩家，右边分数给列玩家。纳什均衡的核心不是“最优雅”或“总分最高”，而是“在对方不改的前提下，我单独改策略也不会更好”。');

      if (pureNash.length) {
        lines.push(`这局找到了 ${pureNash.length} 个纯策略纳什均衡。`);
        pureNash.forEach((eq, idx) => {
          const rowLabel = state.rowLabels[eq.i];
          const colLabel = state.colLabels[eq.j];
          const rowBest = bestReplyListForColumn(eq.j, 'row').join('、');
          const colBest = bestReplyListForRow(eq.i, 'col').join('、');
          lines.push(`纯均衡 ${idx + 1}：${labelCell(eq.i, eq.j)} = (${formatNum(eq.payoff[0])}, ${formatNum(eq.payoff[1])})。如果列玩家固定选“${colLabel}”，行玩家看这一列时最不想改（最佳回应里包含“${rowLabel}”，同列最佳回应集合：${rowBest}）；如果行玩家固定选“${rowLabel}”，列玩家也同理（最佳回应集合：${colBest}）。所以双方都没有单方面改主意的动力。`);
        });
      } else {
        lines.push('这局没有纯策略纳什均衡。通俗说，就是只要你把棋子停在某一个单格，总有一方会说“我换一下更赚”。');
      }

      if (mixedNash.equilibria.length) {
        const eq = mixedNash.equilibria[0];
        const rowMix = formatStrategyDistribution(eq.p, state.rowLabels, true);
        const colMix = formatStrategyDistribution(eq.q, state.colLabels, true);
        lines.push(`至少找到 ${mixedNash.equilibria.length} 个混合策略纳什均衡。拿第一个来说：行玩家按“${rowMix}”随机出招，列玩家按“${colMix}”随机出招。这样做的直觉是：双方把对手“打平”了，让对方支持集里的几个策略期望收益一样高（或一样低），所以对方临时偏向其中一个也不会更占便宜。`);
        lines.push(`这个混合均衡下的期望收益大约是 (${formatNum(eq.rowValue)}, ${formatNum(eq.colValue)})。`);
      } else {
        lines.push('页面当前没有找到混合策略纳什。可能是真的没有，也可能是这个例子属于退化情况（支持集枚举没覆盖到）。如果想验证功能，可以试试“正反硬币”“石头剪刀布”“性别之战”这些预设。');
      }

      if (iesds.steps.length) {
        const preview = iesds.steps.slice(0, 3).map((step, idx) => `第 ${idx + 1} 步：${step.text}`).join(' ');
        const finalRows = iesds.final.activeRows.map(i => state.rowLabels[i]).join('、') || '无';
        const finalCols = iesds.final.activeCols.map(j => state.colLabels[j]).join('、') || '无';
        lines.push(`IESDS 的意思是：先删掉“无论对方怎么选都更差”的策略（严格支配策略）。这局一共能删 ${iesds.steps.length} 步。${preview}`);
        lines.push(`删完后剩下的候选策略集合是：行玩家 {${finalRows}}，列玩家 {${finalCols}}。这一步不一定直接给出所有 Nash，但能明显缩小思考范围。`);
      } else {
        lines.push('IESDS 这边没有可删的严格支配策略。注意这不代表“没有均衡”，只表示“靠严格支配删除法没法先简化”。');
      }

      lines.push('一句记忆法：纳什均衡 = “我不先改，你也不想先改”。');
      return lines.join('\n\n');
    }

    function renderIesdsPanel() {
      const info = state.analysis?.iesds;
      if (!info) return;

      const maxStep = info.steps.length;
      if (state.iesdsStepIndex > maxStep) state.iesdsStepIndex = maxStep;

      const frame = getIesdsFrame(info, state.iesdsStepIndex);
      const lastStep = state.iesdsStepIndex > 0 ? info.steps[state.iesdsStepIndex - 1] : null;

      els.iesdsStatus.innerHTML = buildIesdsStatusHtml(info, frame, lastStep);
      els.iesdsMatrix.innerHTML = buildIesdsMatrixHtml(info, frame, lastStep);
      els.iesdsTimeline.innerHTML = buildIesdsTimelineHtml(info, state.iesdsStepIndex);

      els.iesdsPrevBtn.disabled = state.iesdsStepIndex <= 0;
      els.iesdsNextBtn.disabled = state.iesdsStepIndex >= maxStep;
      els.iesdsResetBtn.disabled = state.iesdsStepIndex === 0;
      els.iesdsPlayBtn.textContent = state.iesdsPlaying ? '暂停' : (state.iesdsStepIndex >= maxStep ? '重播' : '播放');
      els.iesdsPlayBtn.disabled = maxStep === 0;

      els.iesdsTimeline.querySelectorAll('button[data-step]').forEach(btn => {
        btn.addEventListener('click', () => setIesdsStep(Number(btn.dataset.step)));
      });
    }

    function buildIesdsStatusHtml(info, frame, lastStep) {
      const stepLine = info.steps.length
        ? `步骤 ${state.iesdsStepIndex} / ${info.steps.length}`
        : '没有可删除的严格支配策略';
      const rowsText = frame.activeRows.map(i => state.rowLabels[i]).join('、') || '无';
      const colsText = frame.activeCols.map(j => state.colLabels[j]).join('、') || '无';
      const actionText = lastStep ? lastStep.text : '初始状态：还没开始删除。';
      return `
        <strong>${escapeHtml(stepLine)}</strong><br>
        ${escapeHtml(actionText)}<br>
        当前保留：行玩家 {${escapeHtml(rowsText)}}；列玩家 {${escapeHtml(colsText)}}
      `;
    }

    function buildIesdsMatrixHtml(info, frame, lastStep) {
      const activeRowSet = new Set(frame.activeRows);
      const activeColSet = new Set(frame.activeCols);
      const removedRow = lastStep && lastStep.type === 'row' ? lastStep.removed : null;
      const removedCol = lastStep && lastStep.type === 'col' ? lastStep.removed : null;
      const domRow = lastStep && lastStep.type === 'row' ? lastStep.by : null;
      const domCol = lastStep && lastStep.type === 'col' ? lastStep.by : null;

      let html = '<table class="iesds-table" aria-label="IESDS 动画矩阵"><thead><tr><th>R\\C</th>';
      for (let j = 0; j < state.cols; j++) {
        const classes = [];
        if (!activeColSet.has(j)) classes.push('inactive');
        if (removedCol === j) classes.push('removed', 'head-cut');
        if (domCol === j) classes.push('dominator', 'head-dominator');
        html += `<th class="${classes.join(' ')}">${escapeHtml(state.colLabels[j])}</th>`;
      }
      html += '</tr></thead><tbody>';

      for (let i = 0; i < state.rows; i++) {
        const headClasses = [];
        if (!activeRowSet.has(i)) headClasses.push('inactive');
        if (removedRow === i) headClasses.push('removed', 'head-cut');
        if (domRow === i) headClasses.push('dominator', 'head-dominator');
        html += `<tr><th class="${headClasses.join(' ')}">${escapeHtml(state.rowLabels[i])}</th>`;
        for (let j = 0; j < state.cols; j++) {
          const classes = [];
          if (!activeRowSet.has(i) || !activeColSet.has(j)) classes.push('inactive');
          if (removedRow === i || removedCol === j) classes.push('focus-cut');
          if ((domRow === i && activeColSet.has(j)) || (domCol === j && activeRowSet.has(i))) classes.push('dominator');
          if ((removedRow === i && !activeRowSet.has(i)) || (removedCol === j && !activeColSet.has(j))) classes.push('removed');
          html += `<td class="${classes.join(' ')}">${formatNum(state.A[i][j])}, ${formatNum(state.B[i][j])}</td>`;
        }
        html += '</tr>';
      }
      html += '</tbody></table>';
      return html;
    }

    function buildIesdsTimelineHtml(info, currentStep) {
      if (!info.steps.length) {
        return '<button class="ghost active-step" type="button" disabled>无可删步骤</button>';
      }
      const chips = [`<button class="ghost ${currentStep === 0 ? 'active-step' : ''}" type="button" data-step="0">初始</button>`];
      info.steps.forEach((step, idx) => {
        const label = step.type === 'row'
          ? `删 ${state.rowLabels[step.removed]}`
          : `删 ${state.colLabels[step.removed]}`;
        chips.push(`<button class="ghost ${currentStep === idx + 1 ? 'active-step' : ''}" type="button" data-step="${idx + 1}">${escapeHtml(label)}</button>`);
      });
      return chips.join('');
    }

    function getIesdsFrame(info, stepIndex) {
      if (stepIndex <= 0) return { ...info.initial, activeRows: [...info.initial.activeRows], activeCols: [...info.initial.activeCols] };
      const step = info.steps[Math.min(stepIndex, info.steps.length) - 1];
      return { activeRows: [...step.after.activeRows], activeCols: [...step.after.activeCols] };
    }

    function getIesdsStepCount() {
      return state.analysis?.iesds?.steps.length || 0;
    }

    function setIesdsStep(next) {
      stopIesdsPlay();
      const max = getIesdsStepCount();
      state.iesdsStepIndex = clamp(next, 0, max);
      renderIesdsPanel();
    }

    function toggleIesdsPlay() {
      const max = getIesdsStepCount();
      if (!max) return;
      if (state.iesdsPlaying) {
        stopIesdsPlay();
        renderIesdsPanel();
        return;
      }
      if (state.iesdsStepIndex >= max) state.iesdsStepIndex = 0;
      state.iesdsPlaying = true;
      renderIesdsPanel();
      state.iesdsTimer = setInterval(() => {
        const cap = getIesdsStepCount();
        if (state.iesdsStepIndex >= cap) {
          stopIesdsPlay();
          renderIesdsPanel();
          return;
        }
        state.iesdsStepIndex += 1;
        renderIesdsPanel();
        if (state.iesdsStepIndex >= cap) {
          stopIesdsPlay();
          renderIesdsPanel();
        }
      }, 950);
    }

    function stopIesdsPlay() {
      state.iesdsPlaying = false;
      if (state.iesdsTimer) {
        clearInterval(state.iesdsTimer);
        state.iesdsTimer = null;
      }
    }

    function bestReplyListForColumn(colIndex, playerType) {
      if (!state.analysis) return [];
      if (playerType !== 'row') return [];
      return state.analysis.bestResponses.rowBestByCol[colIndex].map(i => state.rowLabels[i]);
    }

    function bestReplyListForRow(rowIndex, playerType) {
      if (!state.analysis) return [];
      if (playerType !== 'col') return [];
      return state.analysis.bestResponses.colBestByRow[rowIndex].map(j => state.colLabels[j]);
    }

    function labelCell(i, j) {
      return `(${state.rowLabels[i]}, ${state.colLabels[j]})`;
    }

    function formatStrategyDistribution(probs, labels, compact = false) {
      return probs
        .map((p, idx) => ({ p, idx }))
        .filter(item => item.p > 1e-5)
        .map(item => `${labels[item.idx]}:${compact ? formatProb(item.p) : formatProb(item.p)}`)
        .join(compact ? '，' : ' | ');
    }

    function formatProb(v) {
      if (Math.abs(v - 1 / 3) < 1e-4) return '1/3';
      if (Math.abs(v - 2 / 3) < 1e-4) return '2/3';
      if (Math.abs(v - 1 / 2) < 1e-4) return '1/2';
      return trimZeros(v.toFixed(3));
    }

    function dot(a, b) {
      let sum = 0;
      for (let i = 0; i < a.length; i++) sum += a[i] * b[i];
      return sum;
    }

    function combinations(n, k) {
      const out = [];
      const pick = [];
      function dfs(start) {
        if (pick.length === k) {
          out.push([...pick]);
          return;
        }
        for (let i = start; i <= n - (k - pick.length); i++) {
          pick.push(i);
          dfs(i + 1);
          pick.pop();
        }
      }
      dfs(0);
      return out;
    }

    function allStrictlyPositive(arr) {
      return arr.every(v => v > 1e-6 && Number.isFinite(v));
    }

    function normalizeTinyInPlace(arr) {
      let sum = 0;
      for (let i = 0; i < arr.length; i++) {
        if (Math.abs(arr[i]) < 1e-10) arr[i] = 0;
        sum += arr[i];
      }
      if (Math.abs(sum) > 1e-10) {
        for (let i = 0; i < arr.length; i++) arr[i] /= sum;
      }
    }

    function isPureStrategyVector(v) {
      let count = 0;
      for (const x of v) {
        if (x > 1 - 1e-6) count += 1;
        else if (x < 1e-6) continue;
        else return false;
      }
      return count === 1;
    }

    function probsKey(p, q) {
      const round = arr => arr.map(v => trimZeros((Math.abs(v) < 1e-10 ? 0 : v).toFixed(6))).join(',');
      return `${round(p)}|${round(q)}`;
    }

    function randomInt(min, maxInclusive) {
      return Math.floor(Math.random() * (maxInclusive - min + 1)) + min;
    }

    function ensureLabelArray(input, len, prefix) {
      const arr = Array.isArray(input) ? [...input] : [];
      while (arr.length < len) arr.push(`${prefix}${arr.length + 1}`);
      return arr.slice(0, len);
    }

    function cloneMatrix(matrix) {
      return matrix.map(row => [...row]);
    }

    function clamp(v, min, max) {
      return Math.max(min, Math.min(max, v));
    }

    function formatEditable(v) {
      return Number.isFinite(v) ? trimZeros(String(v)) : '0';
    }

    function formatNum(v) {
      if (!Number.isFinite(v)) return 'NaN';
      const rounded = Math.abs(v) < 1e-10 ? 0 : v;
      return trimZeros(rounded.toFixed(3));
    }

    function trimZeros(str) {
      return str.replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'');
    }

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function escapeAttr(str) {
      return escapeHtml(str);
    }

    init();
  </script>
</body>
</html>
